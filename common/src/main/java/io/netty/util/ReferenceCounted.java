package io.netty.util;

/**
 * >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 * 简介：
 * ReferenceCounted 接口是 Netty 中用于实现引用计数功能的核心接口。它允许对象在不再被引用时能够被显式地回收，
 * 这对于管理如 ByteBuf 这样的资源非常关键，尤其是在处理直接内存（堆外内存）时，因为直接内存的分配和回收比堆内
 * 存更为昂贵，且不会自动由 JVM 的垃圾回收器管理。

 * >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 * 工作原理：
 * 当一个对象实现了 ReferenceCounted 接口，它就具备了引用计数的能力。这个对象的生命周期开始时，引用计数器初始化为1。
 * 通过调用 retain() 方法可以增加引用计数，而 release() 方法则减少引用计数。如果引用计数减少到0，对象将被显式回收。
 * 如果尝试访问已经被回收的对象，通常会抛出访问违规异常。

 * >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 * 应用场景：
 * 在 Netty 的网络编程中，ByteBuf 对象经常在不同的处理器之间传递。通过引用计数机制，可以确保 ByteBuf 对象在不再
 * 需要时能够被及时释放，避免内存泄漏。例如，在 ChannelPipeline 中处理消息时，每个处理器处理完消息后，需要根据是
 * 否继续传递消息来决定是否调用 release() 方法。
 *
 */
public interface ReferenceCounted {
    /**
     * 返回对象的引用计数。如果返回0，意味着对象已经被回收。
     */
    int refCnt();

    /**
     * 将引用计数增加1。
     */
    ReferenceCounted retain();

    /**
     * 将引用计数增加指定数量。
     */
    ReferenceCounted retain(int increment);

    /**
     * 出于调试目的，用一个额外的任意信息记录这个对象的当前访问地址。如果这个对象被检测到泄露了，这个操作记录的信息将通过 ResourceLeakDetector 提供。
     */
    ReferenceCounted touch();

    /**
     * 同上，但允许提供额外的提示信息。
     */
    ReferenceCounted touch(Object hint);

    /**
     * 将引用计数减一。如果引用计数达到0，则回收这个对象，并返回true；否则返回false。
     */
    boolean release();

    /**
     * 将引用计数减少指定数量。如果引用计数达到0，则回收这个对象，并返回true；否则返回false。
     */
    boolean release(int decrement);
}
